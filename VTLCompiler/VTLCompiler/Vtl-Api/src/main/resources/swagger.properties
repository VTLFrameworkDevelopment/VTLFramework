engineController.buildStatements=Esegue l'interpretazione degli statement VTL
engineController.buildStatements.notes=Prende in ingresso uno o più comandi VTL e restituisce la struttura di oggetti di interpretazione. Restituisce la lista di oggetti interpretati
engineController.buildStatements.param.commandStatements.description=I comandi VTL che devono essere interpretati
engineController.checkInstruction=Esegue una validazione sintattica degli statement VTL
engineController.checkInstruction.notes=Prende in ingresso uno o più comandi VTL e verifica la presenza di errori. Il metodo genera eccezione se ne trova.
engineController.checkInstruction.param.commandStatements.description=I comandi VTL che devono essere validati sintatticamente
engineController.orderInstruction=Esegue l'ordinamento degli statement VTL
engineController.orderInstruction.notes=Prende in ingresso uno o più comandi VTL e li ordina. Restituisce la lista di oggetti interpretati.
engineController.orderInstruction.param.commandStatements.description=I comandi VTL che devono essere ordinati
engineController.validate=Attiva il motore semantico dell'applicazione
engineController.validate.notes=Prende in ingresso una lista di comandi ed effettua: Controllo sintattico,ordinamento,interpretazione e validazione semantica. Il risultato dell'operazione può essere restituita sotto forma di JSON o sotto forma di SDMX-XML
engineController.validate.param.resultType.description=Determina il formato di output della validazione. Può assumere il valore JSON per avere le strutture oppure il valore XML per avere il risultato in SDMX
engineController.validate.param.commandStatements.description=I comandi VTL che devono essere validati
engineController.validateAndShowPassages=Attiva il motore semantico dell'applicazione e restituisce tutti i singoli passaggi. Utilizzato a fini di test o verifica.
engineController.validateAndShowPassages.notes=Prende in ingresso una lista di comandi VTL ed effettua: controllo sintattico,ordinamento,interpretazione e validazione semantica. Restituisce tutti i passaggi intermedi di validazione
engineController.validateAndShowPassages.param.commandStatements.description=I comandi VTL che devono essere validati
engineController.translate=Esegue la traduzione verso SQL degli statement VTL
engineController.translate.notes=Prende in ingresso una lista di comandi VTL ed effettua: controllo sintattico, ordinamento, interpretazione, validazione semantica e traduzione. Il Sql verso cui deve essere effettuata la traduzione è indicato nella chiamata
engineController.translate.param.commandStatements.description=I comandi VTL che devono essere tradotti verso SQL
engineController.translate.param.sqlType.description=Indica il tipo di SQL verso cui si vuole effettuare la traduzione, può assumere i valori OracleSql, MySQL, PostgreSQL, SQLServer . il valore è case insensitive
evaluation.evaluateOnTheFly=Attiva i motori VTL in un unica invocazione
evaluation.evaluateOnTheFly.notes=Prende in ingresso una richiesta di elaborazione VTL e restituisce, la validazione semantica o la traduzione. Il metodo crea i dataset,le funzioni controlla sintatticamente i comandi VTL, li interpreta, li valida e infine li traduce in SQL. Secondo i parametri in ingresso è possibile eseguire la sola validazione, ottenere la struttura sdmx o tradurre i comandi.
evaluation.evaluateOnTheFly.param.vtlRequest.description=Un json di ingresso che contiene tutti il contesto dei comandi VTL che si vogliono eseguire.
vtlRequest.functions.notes=Le user function VTL che si vogliono eseguire separate da un punto e virgola. Può non essere valorizzata.
vtlRequest.functions.example=define operator max_int (x integer, y integer) returns integer is if x > y then x else y end operator;
vtlRequest.datasets.notes=I dataset che si vogliono elaborare. Può non essere valorizzata
vtlRequest.datasets.example="datasets":[{"name":"ds_1","isPersistent":true,"componentsDescriptions":"ID_1,STRING,IDENTIFIER;ME_1,NUMBER,MEASURE"},{"name":"ds_2","isPersistent":true,"componentsDescriptions":"ID_1,STRING,IDENTIFIER;ID_2,STRING,IDENTIFIER;ME_1,NUMBER,MEASURE"},{"name":"ds_3","isPersistent":true,"vtlComponents":[{"name":"ID_1","type":"STRING","vtlComponentRole":"IDENTIFIER","valueDomain":"string_vd","valueDomainParent":"string_vd"},{"name":"ID_2","type":"STRING","vtlComponentRole":"IDENTIFIER","valueDomain":"string_vd","valueDomainParent":"string_vd"},{"name":"ME_1","type":"NUMBER","vtlComponentRole":"MEASURE","valueDomain":"string_vd","valueDomainParent":"string_vd"}]}]
vtlRequest.statements.notes=Gli statements VTL da elaborare separati da un punto e virgola
vtlRequest.statements.example=ds_r := 2+5; ds_r2 := Ds_2 +4; DS_r3 := max_int(2, 3);ds_4 <- ds_1+ds_2+ds_3;
vtlRequest.requestUuid.notes=La requestUuid di sessione. Può non essere valorizzata
vtlRequest.requestUuid.example=756ef45a-7340-11ea-bc55-0242ac130003
vtlRequest.onlyValidation.notes=il flag determina se si sta richiedendo solo la validazione. Può essere omesso
vtlRequest.onlyValidation.example=false
vtlRequest.xmlResult.notes=il flag determina se si sta richiedendo solo la validazione in formato XML. Può essere omesso
vtlRequest.xmlResult.example=false
vtlRequest.sqlType.notes=Il parametro determina quale tipo di SQL si vuole in traduzione. Il flag può essere ignorato se si richiede solao la validazione. i valori possibili sono oracleSql, SqlServer, MySql, postgreSql
vtlRequest.sqlType.example=oracleSql
vtlRequest.aliases.notes=La lista delle rinominazioni che si devono effettuare nel SQL di traduzione. Può essere omesso.
vtlRequest.aliases.example="aliases":[{"name":"dS_2", "alias":"test"}]
datasetRename.name.notes=il nome del dataset da rinominare. E' case insensitive
datasetRename.name.example=ds_2
datasetRename.alias.notes=il nome del dataset che sostituirà il precedente
datasetRename.alias.example=test
vtlDataset.name.notes=il nome del dataset
vtlDataset.name.example=ds_1
vtlDataset.description.notes=la descrizione del dataset. non richiesto
vtlDataset.description.example=il dataset che rappresenta la tabella di rilevazione del latte
vtlDataset.isOnlyAScalar.notes=il flag determina se si sta rappresentando solo uno scalare
vtlDataset.isOnlyAScalar.example=false
vtlDataset.isPersistent.notes=il flag determina se la tabella a cui fa riferimento esiste fisicamente e può essere richiamata ovunque
vtlDataset.isPersistent.example=false
vtlDataset.vtlComponentLites.notes=la lista di componenti che appartengono al dataset.O viene valorizzato questo campo o viene valorizzato quello del componentsDescriptions
vtlDataset.vtlComponentLites.example="vtlComponents":[{"name":"ID_1","type":"STRING","vtlComponentRole":"IDENTIFIER","valueDomain":"string_vd","valueDomainParent":"string_vd"},{"name":"ID_2","type":"STRING","vtlComponentRole":"IDENTIFIER","valueDomain":"string_vd","valueDomainParent":"string_vd"},{"name":"ME_1","type":"NUMBER","vtlComponentRole":"MEASURE","valueDomain":"string_vd","valueDomainParent":"string_vd"}]
vtlDataset.componentsDescriptions.notes=una stringa che descrive i componenti del componente. E' costruita con la struttura [Nome componente],[Tipo componente],[Ruolo componente];
vtlDataset.componentsDescriptions.example=ID_1,STRING,IDENTIFIER;ME_1,NUMBER,MEASURE
vtlDataset.requestUuid.notes=La requestUuid legata al dataset. non deve essere popolato
vtlDataset.requestUuid.example=756ef45a-7340-11ea-bc55-0242ac130003
vtlComponent.type.notes=il tipo del componente [string,number,integer,boolean, time,time_period,date,duration]
vtlComponent.type.example=INTEGER
vtlComponent.name.notes=il nome del componente
vtlComponent.name.example=ds_1
vtlComponent.domainValue.notes=il domain value del componente 
vtlComponent.domainValue.example=integer_vd
vtlComponent.domainValueParent.notes=il domain value progenitore del componente
vtlComponent.domainValueParent.example=number_vd
vtlComponent.vtlComponentRole.notes=il ruolo del componente [IDENTIFIER,MEASURE,ATTRIBUTE,VIRAL]
vtlComponent.vtlComponentRole.example=IDENTIFIER
vtlPackage.downloadFile=Download del file di package
vtlPackage.downloadFile.notes=il metodo offre un file SQL che contiene il package delle procedure e funzioni per la traduzione dei comandi VTL.
vtlPackage.downloadFile.param.filename.description=Il sql di cui si vuole il file. Può avere valori oracleSql,sqlServer, mySql, postgreSql
sdmxController.downloadFile=Download del file di struttura di un dataset
sdmxController.downloadFile.notes=Dato in ingresso un nome di un dataset offre la struttura sdmx corrispondente. Genera un file di estensione xml con lo stesso nome del dataset
sdmxController.downloadFile.param.datasetName.description=il nome del dataset da scaricare
userFunctionController.getAllFunction=Restituisce tutte le userDefineFunction
userFunctionController.getAllFunction.notes=Restituisce tutte le userDefineFunction salvate
userFunctionController.createUserFunction=crea una userDefineFunction
userFunctionController.createUserFunction.notes=Crea una nuova userDefineFunction
userFunctionController.createUserFunction.param.function.description=la funzione da salvare
userFunctionController.editUserFunction=Modifica una userDefineFunction
userFunctionController.editUserFunction.notes=Modifica una userDefineFunction
serFunctionController.editUserFunction.param.function.description=la funzione da modificare
userFunctionController.getByName=Cerca una userDefineFunction
userFunctionController.getByName.notes=Esegue una ricerca per nome.La ricerca viene fatta in ignoreCase
userFunctionController.getByName.param.userFunctionName.description=il nome della funzione da ricercare
userFunctionController.deleteByName=Cancella una userDefineFunction
userFunctionController.deleteByName.notes=Cancella una una userDefineFunction per nome
userFunctionController.deleteByName.param.userFunctionName.description=il nome della funzione da eliminare
userFunctionController.getAllFunctionByType=Cerca una userDefineFunction per tipo
userFunctionController.getAllFunctionByType.notes=Ricerca tutte le userDefineFunction per tipo funzione. 
userFunctionController.getAllFunctionByType.param.functionType.description=Il tipo di funzione da ricercare. Può assumere valori OPERATOR_FUNCTION, DATAPOINT_FUNCTION, HIERARCHICAL_FUNCTION
vtlDatasetController.getAllDatasets=Restituisce tutti i dataset salvati
vtlDatasetController.getAllDatasets.notes=Restituisce tutti i dataset salvati
vtlDatasetController.getAllDatasetsAsc=Restituisce tutti i dataset salvati
vtlDatasetController.getAllDatasetsAsc.notes=Restituisce tutti i dataset salvati ordinati in ordine alfabetico
vtlDatasetController.createVtlDataset=Crea un nuovo dataset
vtlDatasetController.createVtlDataset.notes=Salva un nuovo dataset sul database interno dell'applicazione
vtlDatasetController.createVtlDatasetByString=Crea un nuovo dataset
vtlDatasetController.createVtlDatasetByString.notes=Salva un nuovo dataset sul database interno dell'applicazione. il metodo di descrizione del dataset prevede una forma contratta della descrizione dei componenti
vtlDatasetController.getByName=ricerca un dataset dal nome
vtlDatasetController.getByName.notes=Effettua una ricerca del dataset ignorando il case sensitive
vtlDatasetController.getByName.param.vtlDatasetName.description=il nome del dataset ricercato
vtlDatasetController.deleteVtlDataset=Cancella un dataset dal nome
vtlDatasetController.deleteVtlDataset.notes=Cancella un dataset dal sistema
vtlDatasetController.deleteVtlDataset.param.vtlDatasetName.description=il nome del dataset da cancellare
vtlDatasetController.deleteAll=Cancella tutti i dataset
vtlDatasetController.deleteAll.notes=Cancella tutti i dataset presenti sul db interno
vtlDatasetController.setUpVtlDatasets=Genera dataset di test
vtlDatasetController.setUpVtlDatasets.notes=Genera una serie di dataset per effettuare dei test sull'applicazione
vtlDatasetController.getValDomainDatasets=Restituisce i valori di un valueDomain
vtlDatasetController.getValDomainDatasets.notes=Ricerca un valueDomain per nome(in case insensitive) e restituisce tutti i valori collegati.
vtlDatasetController.getValDomainDatasets.param.valueDomainName.description=il nome del valueDomain da ricercare
vtlDatasetController.getValDomainDatasetsForValue=Verifica l'esistenza di un valueDomain
vtlDatasetController.getValDomainDatasetsForValue.notes=Verifica l'esistenza di un valueDomain e di un valueCode collegato.
vtlDatasetController.getValDomainDatasetsForValue.param.valueDomainName.description=il nome del valueDomain da ricercare
vtlDatasetController.getValDomainDatasetsForValue.param.valueDomainCode.description=il codice del valueDomain da ricercare
define operator max_int (x integer, y integer) returns integer is if x > y then x else y end operator;",